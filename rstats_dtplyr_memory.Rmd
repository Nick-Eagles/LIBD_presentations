# Intro to `dtplyr`

`dplyr` provides an excellent, expressive language for manipulating data frames
in R. After a slight learning curve, it arguably produces more readable code
while enabling complex, powerful operations. However, a main drawback is that it
wasn't designed to prioritize memory efficiency or speed. `data.table` was
developed as a performant alternative, but has a completely different syntax
that can feel unnatural to those used to base R or `dplyr`.

`dtplyr` bridges this gap, allowing users to write `dplyr` code that *mostly*
gets executed as `data.table` code under the hood. While it can somewhat be
treated as a black box, I find that understanding the logic underlying memory
allocation for various operations is useful to write the most performant code
while avoiding unexpected behavior.

## Understanding Memory Allocation in R

First, let's talk about memory allocation in base R, which feels quite similar
to how `dplyr` works. In particular, both protect the user from accidentally
modifying an existing object during a series of modifications, often at the
expense of memory efficiency.

### R's Default Behavior: Copy on Modify

```{r 'copy_on_modify'}
library(tidyverse)
library(data.table)
library(dtplyr)

a = tibble(x = 1:3)

#   At this point, a second tibble is not created. 'b' just points to the same
#   location in memory as 'a'; it's a reference, not copy
b = a

#   However, the second we modify 'b', R actually creates a full copy of 'a',
#   then adds a column to the new tibble
b$y = 4:6

#   Note that 'a' remains unchanged
a
```

This behavior applies for almost all ordinary objects in base R, like vectors,
lists, and data frames!

### `dplyr`'s behavior

Somewhat similarly, adding a column to a data frame with `dplyr` creates a full
copy of the starting data frame before adding the new column:

```{r 'dplyr_mutate'}
a = tibble(x = 1:3)

#   'a' is fully copied, then the new column is added to 'b', the copy
b = mutate(a, y = 4:6)
```

Actually, every `dplyr` verb creates a copy of at least some of the starting
data, even, for example, `select()`, `filter()`, and `arrange()`.

### `data.table`'s Behavior (Certain Operations)

In contrast, `data.table` tries to avoid data copies as much as possible and
instead use references to the original object. Let's again consider the example
of adding a column to an existing data frame:

```{r 'data_table_mutate'}
a = data.table(x = 1:3)

#   Use the ':=' operator to add a column by reference. The existing data
#   stays where it is (the 'x' column), and the new column 'y' is added to 'a'
a[, y := 4:6]
```

Other examples of operations that modify a reference include functions that
start with `set`. For example, `setnames()` changes colnames by reference
(shockingly, `colnames<-` does not-- some underlying data is copied!):

```{r 'data_table_setnames'}
setnames(a, c("x_new", "y_new"))

a
```

Another handy function is `setDT()`, which can take a data-frame-like object
(e.g. a `tibble` or `data.frame`) and convert it to a `data.table` by reference.
If you use `data.table()` to cast the starting object, it gets copied!
